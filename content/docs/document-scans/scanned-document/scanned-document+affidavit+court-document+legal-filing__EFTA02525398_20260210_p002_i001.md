---
source_image: "scanned-document+affidavit+court-document+legal-filing__EFTA02525398_20260210_p002_i001.png"
source_pdf: "EFTA02525398.pdf"
method: pdf_text
words: 673
confidence: 1.00
extracted: 2026-02-13T17:18:11.177761
---

> reversibility, the theory should cohort with the evidence. I am =ware of your beliefr structure the god of zero and 
one plus =omputablity. but it seems fillled with fudge. ?:)/ if it doesnt fit =he model take it out . stringtheory had the 
same flaw, in reverse , =f it didnt fit , add more. 
> On Mon, Feb 19, 2018 at 6:24 AM, Joscha Bach 
=rote: 
> As you may have noticed, my whole train of thought on computationalism =s based on the rediscovery of intutionist 
mathematics under the name =computation". 
> =tp://math.andrej.com/wp-content/uploads/2014/03/real-world-realizabil 
> ity.=df 
> The difference between classical math and computation is that =lassically, a function has a value as soon as it is 
defined, but in the =omputational paradigm, it has to be actually computed, using some =enerator. This also applies for 
functions that designate truth. For =omething to be true in intuitionist mathematics, you will always have =o show the 
money: you have to demonstrate that you know how to make a =rocess that can actually perform the necessary steps. 
> This has some interesting implication: computation cannot be =aradoxical. In the computational framework, there can 
be no set of all =ets that does not contain itself. Instead, you'd have to define =unctions that add and remove sets from 
each other, and as a result, you =ight up with some periodic fluctuation, but not with an illegal state. 
> Intuitionist math fits together with automata theory. It turns out =hat there is a universal computer, i.e. a function that 
can itself =ompute all computable functions (Turing completeness). All functions =hat implement the universal computer 
can effectively compute the same =et of functions, but they may differ in how efficiently they can do it. =fficiency relates 
to computational complexity classes. 
> The simplest universal computers known are some cellular automata, =ith Minsky and Wolfram arguing about who 
found the shortest one. =oolean algebra is Turing complete, too, as is the NAND gate, the lambda =alculus, and almost 
all programming languages. The Church Turing thesis =ays that all universal computers can compute each other, and 
therefore =ave the same power. 
> I suspect that it is possible that the Church Turing thesis is also a =hysical law, i.e. it is impossible to build physical 
computer that can =alculate more than a Turing machine. However, that conflicts with the =raditional intuitions of most 
of physics: that the universe is =eometric, i.e. hypercomputational. The fact that we cannot construct a =ypercomputer, 
not just not in physics, but also not mathematically =where we take its existence as given when we perform geometry), 
makes =e suspect that perhaps even God cannot make a true geometric universe. 
> How can we recover continuous space from discrete computation? Well, =pacetime is the set of all locations that can 
store information, and =he set of all trajectories along which this information can flow, as =een from the perspective of 
an observer. We can get such an arrangement =rom a flat lattice (i.e. a graph) that is approximately regular and =ine 
grained enough. If we disturb the lattice structure by adding more =inks, we get nonlocality (i.e. some information 
appears in distant =attice positions), and if we remove links, we get spatial superposition =some locations are not 
dangling, so we cannot project them to a single =oordinate any more, but must project them into a region). 
> On the elementary level, we can define a space by using a set of =bjects, and a bijective function that maps a scalar 
value to a subset =f these objects. The easiest way of doing might be to define a typed =elationship that orders each pair 
of objects, and differences in the =calar are mapped to the number of successive links of that relationship =ype. We can 
use multiple relationship types to obtain multiple =imensions, and if we choose the relationships suitably we may also 
=onstruct operators that relate the dimensions to each other via =ranslation, rotation and nesting, so we derive the 
properties of =uclidean spaces. 
2 
EFTA_R1_01665141 
EFTA02525399
